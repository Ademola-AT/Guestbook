// Code generated by gowire. DO NOT EDIT.

//+build !wireinject

package main

import (
	context "context"
	sql "database/sql"
	client "github.com/aws/aws-sdk-go/aws/client"
	session "github.com/aws/aws-sdk-go/aws/session"
	mysql "github.com/go-sql-driver/mysql"
	blob "github.com/google/go-cloud/blob"
	fileblob "github.com/google/go-cloud/blob/fileblob"
	gcsblob "github.com/google/go-cloud/blob/gcsblob"
	s3blob "github.com/google/go-cloud/blob/s3blob"
	gcp "github.com/google/go-cloud/gcp"
	cloudmysql "github.com/google/go-cloud/mysql/cloudmysql"
	rdsmysql "github.com/google/go-cloud/mysql/rdsmysql"
	requestlog "github.com/google/go-cloud/requestlog"
	runtimevar "github.com/google/go-cloud/runtimevar"
	filevar "github.com/google/go-cloud/runtimevar/filevar"
	paramstore "github.com/google/go-cloud/runtimevar/paramstore"
	runtimeconfigurator "github.com/google/go-cloud/runtimevar/runtimeconfigurator"
	server "github.com/google/go-cloud/server"
	sdserver "github.com/google/go-cloud/server/sdserver"
	xrayserver "github.com/google/go-cloud/server/xrayserver"
	trace "go.opencensus.io/trace"
	http "net/http"
	time "time"
)

// Injectors from inject_aws.go:

func setupAWS(ctx context.Context) (*app, func(), error) {
	ncsaLogger := xrayserver.NewRequestLogger()
	client := http.DefaultClient
	certFetcher := &rdsmysql.CertFetcher{
		Client: client,
	}
	params := awsSQLParams()
	db, cleanup, err := rdsmysql.Open(ctx, certFetcher, params)
	if err != nil {
		return nil, nil, err
	}
	v, cleanup2 := appHealthChecks(db)
	options := session.Options{}
	session2, err := session.NewSessionWithOptions(options)
	if err != nil {
		cleanup2()
		cleanup()
		return nil, nil, err
	}
	xRay := xrayserver.NewXRayClient(session2)
	exporter, cleanup3, err := xrayserver.NewExporter(xRay)
	if err != nil {
		cleanup2()
		cleanup()
		return nil, nil, err
	}
	sampler := trace.AlwaysSample()
	options2 := &server.Options{
		RequestLogger:         ncsaLogger,
		HealthChecks:          v,
		TraceExporter:         exporter,
		DefaultSamplingPolicy: sampler,
	}
	server2 := server.New(options2)
	bucket, err := awsBucket(ctx, session2)
	if err != nil {
		cleanup3()
		cleanup2()
		cleanup()
		return nil, nil, err
	}
	backends2 := backends{
		srv:    server2,
		db:     db,
		bucket: bucket,
	}
	client2 := paramstore.NewClient(ctx, session2)
	variable, err := awsMOTDVar(ctx, client2)
	if err != nil {
		cleanup3()
		cleanup2()
		cleanup()
		return nil, nil, err
	}
	app2 := newApp(backends2, variable)
	return app2, func() {
		cleanup3()
		cleanup2()
		cleanup()
	}, nil
}

// Injectors from inject_gcp.go:

func setupGCP(ctx context.Context) (*app, func(), error) {
	stackdriverLogger := sdserver.NewRequestLogger()
	roundTripper := gcp.DefaultTransport()
	credentials, err := gcp.DefaultCredentials(ctx)
	if err != nil {
		return nil, nil, err
	}
	tokenSource := gcp.CredentialsTokenSource(credentials)
	httpClient, err := gcp.NewHTTPClient(roundTripper, tokenSource)
	if err != nil {
		return nil, nil, err
	}
	remoteCertSource := cloudmysql.NewCertSource(httpClient)
	projectID, err := gcp.DefaultProjectID(credentials)
	if err != nil {
		return nil, nil, err
	}
	params := gcpSQLParams(projectID)
	db, err := cloudmysql.Open(ctx, remoteCertSource, params)
	if err != nil {
		return nil, nil, err
	}
	v, cleanup := appHealthChecks(db)
	exporter, err := sdserver.NewExporter(projectID, tokenSource)
	if err != nil {
		cleanup()
		return nil, nil, err
	}
	sampler := trace.AlwaysSample()
	options := &server.Options{
		RequestLogger:         stackdriverLogger,
		HealthChecks:          v,
		TraceExporter:         exporter,
		DefaultSamplingPolicy: sampler,
	}
	server2 := server.New(options)
	bucket, err := gcpBucket(ctx, tokenSource)
	if err != nil {
		cleanup()
		return nil, nil, err
	}
	backends2 := backends{
		srv:    server2,
		db:     db,
		bucket: bucket,
	}
	runtimeConfigManagerClient, cleanup2, err := runtimeconfigurator.Dial(ctx, tokenSource)
	if err != nil {
		cleanup()
		return nil, nil, err
	}
	client := runtimeconfigurator.NewClient(runtimeConfigManagerClient)
	variable, cleanup3, err := gcpMOTDVar(ctx, client, projectID)
	if err != nil {
		cleanup2()
		cleanup()
		return nil, nil, err
	}
	app2 := newApp(backends2, variable)
	return app2, func() {
		cleanup3()
		cleanup2()
		cleanup()
	}, nil
}

// Injectors from inject_local.go:

func setupLocal(ctx context.Context) (*app, func(), error) {
	logger := requestlog.Logger(nil)
	db, err := dialLocalSQL()
	if err != nil {
		return nil, nil, err
	}
	v, cleanup := appHealthChecks(db)
	exporter := trace.Exporter(nil)
	sampler := trace.AlwaysSample()
	options := &server.Options{
		RequestLogger:         logger,
		HealthChecks:          v,
		TraceExporter:         exporter,
		DefaultSamplingPolicy: sampler,
	}
	server2 := server.New(options)
	bucket, err := localBucket()
	if err != nil {
		cleanup()
		return nil, nil, err
	}
	backends2 := backends{
		srv:    server2,
		db:     db,
		bucket: bucket,
	}
	variable, cleanup2, err := localRuntimeVar()
	if err != nil {
		cleanup()
		return nil, nil, err
	}
	app2 := newApp(backends2, variable)
	return app2, func() {
		cleanup2()
		cleanup()
	}, nil
}

// inject_aws.go:

func awsBucket(ctx context.Context, cp client.ConfigProvider) (*blob.Bucket, error) {
	return s3blob.NewBucket(ctx, cp, "wired-sound-199216-sampleapp-bucket")
}

func awsSQLParams() *rdsmysql.Params {
	return &rdsmysql.Params{
		Endpoint: "myinstance.c2wrxifmodyg.us-west-1.rds.amazonaws.com",
		Database: "guestbook",
		User:     "guestbook",
		Password: "xyzzy",
	}
}

func awsMOTDVar(ctx context.Context, client2 *paramstore.Client) (*runtimevar.Variable, error) {
	return client2.NewVariable(ctx, "/sampleapp/motd", runtimevar.StringDecoder, &paramstore.WatchOptions{
		WaitTime: 5 * time.Second,
	})
}

// inject_gcp.go:

func gcpBucket(ctx context.Context, ts gcp.TokenSource) (*blob.Bucket, error) {
	return gcsblob.New(ctx, "wired-sound-199216-sampleapp-bucket", &gcsblob.BucketOptions{
		TokenSource: ts,
	})
}

func gcpSQLParams(id gcp.ProjectID) *cloudmysql.Params {
	return &cloudmysql.Params{
		ProjectID: string(id),
		Region:    "us-central1",
		Instance:  "myinstance",
		Database:  "guestbook",
		User:      "guestbook",
	}
}

func gcpMOTDVar(ctx context.Context, client2 *runtimeconfigurator.Client, project gcp.ProjectID) (*runtimevar.Variable, func(), error) {
	name := runtimeconfigurator.ResourceName{
		ProjectID: string(project),
		Config:    "sampleapp",
		Variable:  "motd",
	}
	v, err := client2.NewVariable(ctx, name, runtimevar.StringDecoder, &runtimeconfigurator.WatchOptions{
		WaitTime: 5 * time.Second,
	})
	if err != nil {
		return nil, nil, err
	}
	return v, func() { v.Close() }, nil
}

// inject_local.go:

func localBucket() (*blob.Bucket, error) {
	return fileblob.NewBucket("blobbucket")
}

func dialLocalSQL() (*sql.DB, error) {
	cfg := &mysql.Config{
		Net:                  "tcp",
		Addr:                 "localhost",
		DBName:               "guestbook",
		User:                 "guestbook",
		Passwd:               "xyzzy",
		AllowNativePasswords: true,
	}
	return sql.Open("mysql", cfg.FormatDSN())
}

func localRuntimeVar() (*runtimevar.Variable, func(), error) {
	v, err := filevar.NewVariable("motd.txt", runtimevar.StringDecoder, &filevar.WatchOptions{
		WaitTime: 5 * time.Second,
	})
	if err != nil {
		return nil, nil, err
	}
	return v, func() { v.Close() }, nil
}
